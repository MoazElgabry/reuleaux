// Created by:
// https://github.com/hotgluebanjo
// https://github.com/calvinsilly

DEFINE_UI_PARAMS(DIRECTION, Direction, DCTLUI_COMBO_BOX, 0, {Forward, Inverse}, {RGB to Reuleaux, Reuleaux to RGB})

__CONSTANT__ float PI_LOCAL = 3.141592653589f;

// This is 100% going to cause complaints.
#define NORM_MULTS make_float3(2.0f * PI_LOCAL, _atan2f(_sqrtf(2.0f), 1.0f), 1.0f)

__DEVICE__ float3 rgb_to_reuleaux(float3 rgb) {
    float3 rotated = {
        _sqrtf(2.0f/3.0f) * (rgb.x - (rgb.y + rgb.z) / 2.0f),
        (rgb.y - rgb.z) / _sqrtf(2.0f),
        (rgb.x + rgb.y + rgb.z) / _sqrtf(3.0f)
    };

    float3 reuleaux = {
        PI_LOCAL - _atan2f(rotated.y, -rotated.x),
        _atan2f(_hypotf(rotated.x, rotated.y), rotated.z),
        _fmaxf(rgb.x, _fmaxf(rgb.y, rgb.z))
    };

    return reuleaux / NORM_MULTS;
}

__DEVICE__ float3 reuleaux_to_rgb(float3 reuleaux) {
    reuleaux *= NORM_MULTS;

    float3 cart;
    cart.x = _cosf(reuleaux.x);
    cart.y = _sinf(reuleaux.x);

    // Tangent with a linear extension. Fixes asymptotic chroma.
    if (reuleaux.y <= NORM_MULTS.y)
        cart.z = 1.0f / _tanf(reuleaux.y);
    else
        cart.z = 1.0f / (3.0f * (reuleaux.y - NORM_MULTS.y) + _sqrtf(2.0f));

    float d_1 = _sqrtf(2.0f) * cart.z + (2.0f * cart.x);
    float d_2 = _sqrtf(2.0f) * cart.z + _sqrtf(3.0f) * cart.y - cart.x;
    float d_3 = _sqrtf(2.0f) * cart.z - _sqrtf(3.0f) * cart.y - cart.x;
    float m = _fmaxf(d_1, _fmaxf(d_2, d_3)) / 3.0f;

    float3 ocs = {
        reuleaux.z * cart.x / m,
        reuleaux.z * cart.y / m,
        reuleaux.z
    };

    float3 rgb;
    bool case_1 = (ocs.y <= 0.0f || ocs.x > 0.0f) && (ocs.x <= 0.0f || ocs.y <= -_sqrtf(3.0f) * ocs.x);
    bool case_2 = (ocs.y > 0.0f || ocs.x > 0.0f) && (ocs.x <= 0.0 || ocs.y > _sqrtf(3.0f) * ocs.x);

    if (case_1) {
        rgb.x = ocs.y / _sqrtf(3.0f) + ocs.x + ocs.z;
        rgb.y = 2.0f / _sqrtf(3.0f) * ocs.y + ocs.z;
        rgb.z = ocs.z;
    } else if (case_2) {
        rgb.x = -ocs.y / _sqrtf(3.0f) + ocs.x + ocs.z;
        rgb.y = ocs.z;
        rgb.z = -(2.0f / _sqrtf(3.0f)) * ocs.y + ocs.z;
    } else {
        rgb.x = ocs.z;
        rgb.y = ocs.y / _sqrtf(3.0f) - ocs.x + ocs.z;
        rgb.z = -ocs.y / _sqrtf(3.0f) - ocs.x + ocs.z;
    }

    return rgb;
}

__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B) {
    float3 input = make_float3(p_R, p_G, p_B);
    float3 res;

    switch (DIRECTION) {
    case Forward:
        res = rgb_to_reuleaux(input);
        break;
    case Inverse:
        res = reuleaux_to_rgb(input);
    }

    return res;
}
