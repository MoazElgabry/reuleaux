// https://github.com/hotgluebanjo

DEFINE_UI_PARAMS(ITS_1, Intensity ~0.0, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 2.0, 0.001)
DEFINE_UI_PARAMS(ITS_2, Intensity ~0.2, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 2.0, 0.001)
DEFINE_UI_PARAMS(ITS_3, Intensity ~0.4, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 2.0, 0.001)
DEFINE_UI_PARAMS(ITS_4, Intensity ~0.6, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 2.0, 0.001)
DEFINE_UI_PARAMS(ITS_5, Intensity ~0.8, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 2.0, 0.001)
DEFINE_UI_PARAMS(ITS_6, Intensity ~1.0, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 2.0, 0.001)

// Range of intensity to adjust by. Defaults to 2*1/5.
DEFINE_UI_PARAMS(ITS_RANGE, Intensity Range, DCTLUI_SLIDER_FLOAT, 0.4, 0.0, 1.0, 0.001)

DEFINE_UI_PARAMS(RED, Red, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 2.0, 0.001)
DEFINE_UI_PARAMS(YEL, Yellow, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 2.0, 0.001)
DEFINE_UI_PARAMS(GRN, Green, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 2.0, 0.001)
DEFINE_UI_PARAMS(CYN, Cyan, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 2.0, 0.001)
DEFINE_UI_PARAMS(BLU, Blue, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 2.0, 0.001)
DEFINE_UI_PARAMS(MAG, Magenta, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 2.0, 0.001)

__DEVICE__ inline float _sqrf(float x) {
    return x * x;
}

__DEVICE__ float gauss_basis(float x, float s) {
    return _expf(-_sqrf(x / s));
}

__DEVICE__ float wrap(float x) {
    if (x < -0.5f) {
        return x + 1.0f;
    } else if (x > 0.5f) {
        return x - 1.0f;
    } else {
        return x;
    }
}

__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B) {
    if (ITS_RANGE < 1e-6f)
        return make_float3(p_R, p_G, p_B);

    float global_ys[6] = { ITS_1, ITS_2, ITS_3, ITS_4, ITS_5, ITS_6 };
    float corner_ys[6] = { RED, YEL, GRN, CYN, BLU, MAG };

    float hue = p_R;
    float chroma = p_G;
    float intensity = p_B;

    for (int i = 0; i < 6; i += 1) {
        float cx = float(i) / 6.0f;
        float mask = gauss_basis(wrap(hue - cx), 1.0f / 6.0f);
        chroma = _mix(chroma, chroma * (intensity * (corner_ys[i] - 1.0f) + 1.0f), mask);
    }

    float sum = 0.0f;
    float weight_sum = 0.0f;

    for (int i = 0; i < 6; i += 1) {
        float cx = float(i) / 5.0f;
        float weight = gauss_basis(intensity - cx, ITS_RANGE);
        sum += weight * global_ys[i];
        weight_sum += weight;
    }

    float intensity_curve = sum / weight_sum;
    float res = chroma * intensity_curve;

    return make_float3(p_R, res, p_B);
}
