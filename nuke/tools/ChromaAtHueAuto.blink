// Matches chroma *y* to chroma *z* at hue *x*.
// https://github.com/hotgluebanjo
kernel ChromaAtHueAuto : ImageComputationKernel<ePixelWise>
{
    Image<eRead, eAccessPoint, eEdgeClamped> src;
    Image<eWrite> dst;

    param:
        float3 red;
        float3 yel;
        float3 grn;
        float3 cyn;
        float3 blu;
        float3 mag;
        float range;
        bool invert;

    local:
        float3 curve[6];

    void define() {
        defineParam(red, "Red", float3(0.0f, 1.0f, 1.0f));
        defineParam(yel, "Yellow", float3(1.0f / 6.0f, 1.0f, 1.0f));
        defineParam(grn, "Green", float3(2.0f / 6.0f, 1.0f, 1.0f));
        defineParam(cyn, "Cyan", float3(3.0f / 6.0f, 1.0f, 1.0f));
        defineParam(blu, "Blue", float3(4.0f / 6.0f, 1.0f, 1.0f));
        defineParam(mag, "Magenta", float3(5.0f / 6.0f, 1.0f, 1.0f));
        defineParam(range, "Range", 1.0f / 6.0f);
        defineParam(invert, "Invert", false);
    }

    void init() {
        curve[0] = red;
        curve[1] = yel;
        curve[2] = grn;
        curve[3] = cyn;
        curve[4] = blu;
        curve[5] = mag;
    }

    float lerp(float a, float b, float t) {
        return (1.0f - t) * a + t * b;
    }

    float gauss_basis(float x, float s) {
        return exp(-pow(x / s, 2.0f));
    }

    float wrap(float x) {
        if (x < -0.5f) {
            return x + 1.0f;
        } else if (x > 0.5f) {
            return x - 1.0f;
        } else {
            return x;
        }
    }

    void process() {
        SampleType(src) input_img = src();

        float hue = input_img.x;
        float chroma = input_img.y;

        for (int i = 0; i < 6; i += 1) {
            float mask = gauss_basis(wrap(hue - curve[i].x), range);
            float ratio = curve[i].z / curve[i].y;
            float adj = invert ? ratio : 1.0f / ratio;
            chroma = lerp(chroma, pow(chroma, adj), mask);
        }

        dst() = float4(input_img.x, chroma, input_img.z, input_img.w);
    }
};
