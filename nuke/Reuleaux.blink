// Created by:
// https://github.com/hotgluebanjo
// https://github.com/calvinsilly

#define M_PI 3.141592653589f

// Returns the f32 sign bit.
inline bool sign_bit(float x) {
    return (*(unsigned*)&x >> 31) != 0;
}

// Returns x with the sign of y.
inline float copy_sign(float x, float y) {
    unsigned ix = *(unsigned*)&x;
    unsigned iy = *(unsigned*)&y;
    ix &= 0x7fffffff;
    ix |= iy & 0x80000000;
    return *(float*)&ix;
}

// Sign-respecting atan2.
// https://github.com/odin-lang/Odin/blob/master/core/math/math.odin#L1476
float atan2_ols(float y, float x) {
    if (y == 0.0f) {
        if (x >= 0 && !sign_bit(x)) {
            return copy_sign(0.0, y);
        }
        return copy_sign(M_PI, y);
    }

    if (x == 0.0f) {
        return copy_sign(M_PI / 2.0f, y);
    }

    float q = atan(y / x);
    if (x < 0.0f) {
        if (q <= 0.0f) {
            return q + M_PI;
        }
        return q - M_PI;
    }

    return q;
}

kernel Reuleaux : ImageComputationKernel<ePixelWise>
{
    Image<eRead, eAccessPoint, eEdgeClamped> src;
    Image<eWrite> dst;

    param:
        bool invert;

    local:
        float3 norm_mults;

    void define() {
        defineParam(invert, "Invert", false);
    }

    void init() {
        norm_mults = float3(
            2.0f * M_PI,
            sqrt(2.0f),
            1.0f
        );
    }

    float3 rgb_to_reuleaux(float3 rgb) {
        float3 rot = float3(
            sqrt(2.0f)/6.0f * (2.0f*rgb.x - rgb.y - rgb.z),
            (rgb.y - rgb.z) / sqrt(6.0f),
            (rgb.x + rgb.y + rgb.z) / 3.0f
        );

        float3 reuleaux = float3(
            M_PI - atan2_ols(rot.y, -rot.x),
            rot.z == 0.0f ? 0.0f : length(float2(rot.x, rot.y)) / rot.z,
            max(rgb.x, max(rgb.y, rgb.z))
        );

        return reuleaux / norm_mults;
    }

    float3 reuleaux_to_rgb(float3 reuleaux) {
        reuleaux *= norm_mults;

        float m = norm_mults.y
            * max(
                cos(reuleaux.x),
                max(
                    cos(reuleaux.x + norm_mults.x/3.0f),
                    cos(reuleaux.x - norm_mults.x/3.0f)
                )
            )
            + 1.0f/reuleaux.y;

        float3 ocs = float3(
            reuleaux.z * cos(reuleaux.x) / m,
            reuleaux.z * sin(reuleaux.x) / m,
            reuleaux.z
        );

        float3 rgb;
        bool case_1 = ocs.x <= -ocs.y/sqrt(3.0f) && ocs.y <= 0.0f;
        bool case_2 = ocs.x < ocs.y/sqrt(3.0f);

        if (case_1) {
            rgb.x = 3.0f/sqrt(2.0f)*ocs.x + sqrt(3.0f/2.0f)*ocs.y + ocs.z;
            rgb.y = sqrt(6.0f)*ocs.y + ocs.z;
            rgb.z = ocs.z;
        } else if (case_2) {
            rgb.x = 3.0f/sqrt(2.0f)*ocs.x - sqrt(3.0f/2.0f)*ocs.y + ocs.z;
            rgb.y = ocs.z;
            rgb.z = -sqrt(6.0f)*ocs.y + ocs.z;
        } else {
            rgb.x = ocs.z;
            rgb.y = -3.0f/sqrt(2.0f)*ocs.x + sqrt(3.0f/2.0f)*ocs.y + ocs.z;
            rgb.z = -3.0f/sqrt(2.0f)*ocs.x - sqrt(3.0f/2.0f)*ocs.y + ocs.z;
        }

        return rgb;
    }

    void process() {
        SampleType(src) input = src();

        float3 triplet = float3(input.x, input.y, input.z);

        if (invert)
            triplet = reuleaux_to_rgb(triplet);
        else
            triplet = rgb_to_reuleaux(triplet);

        dst() = float4(triplet.x, triplet.y, triplet.z, input.w);
    }
};
