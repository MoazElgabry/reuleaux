// Created by:
// https://github.com/hotgluebanjo
// https://github.com/calvinsilly

#define M_PI 3.141592653589f

// Returns the f32 sign bit.
inline bool sign_bit(float x) {
    return (*(unsigned*)&x >> 31) != 0;
}

// Returns x with the sign of y.
inline float copy_sign(float x, float y) {
    unsigned ix = *(unsigned*)&x;
    unsigned iy = *(unsigned*)&y;
    ix &= 0x7fffffff;
    ix |= iy & 0x80000000;
    return *(float*)&ix;
}

// Sign-respecting atan2.
// https://github.com/odin-lang/Odin/blob/master/core/math/math.odin#L1476
float atan2_ols(float y, float x) {
    if (y == 0.0f) {
        if (x >= 0 && !sign_bit(x)) {
            return copy_sign(0.0, y);
        }
        return copy_sign(M_PI, y);
    }

    if (x == 0.0f) {
        return copy_sign(M_PI / 2.0f, y);
    }

    float q = atan(y / x);
    if (x < 0.0f) {
        if (q <= 0.0f) {
            return q + M_PI;
        }
        return q - M_PI;
    }

    return q;
}

kernel Reuleaux : ImageComputationKernel<ePixelWise>
{
    Image<eRead, eAccessPoint, eEdgeClamped> src;
    Image<eWrite> dst;

    param:
        bool invert;

    local:
        float3 norm_mults;

    void define() {
        defineParam(invert, "Invert", false);
    }

    void init() {
        norm_mults = float3(
            2.0f * M_PI,
            atan(sqrt(2.0f)),
            1.0f
        );
    }

    float3 rgb_to_reuleaux(float3 rgb) {
        float3 rotated = float3(
            sqrt(2.0f/3.0f) * (rgb.x - (rgb.y + rgb.z) / 2.0f),
            (rgb.y - rgb.z) / sqrt(2.0f),
            (rgb.x + rgb.y + rgb.z) / sqrt(3.0f)
        );

        float3 reuleaux = float3(
            M_PI - atan2_ols(rotated.y, -rotated.x),
            atan2(sqrt(pow(rotated.x, 2.0f) + pow(rotated.y, 2.0f)), rotated.z),
            max(rgb.x, max(rgb.y, rgb.z))
        );

        return reuleaux / norm_mults;
    }

    float3 reuleaux_to_rgb(float3 reuleaux) {
        reuleaux *= norm_mults;

        float3 cart;
        cart.x = cos(reuleaux.x);
        cart.y = sin(reuleaux.x);

        // Tangent with a linear extension. Fixes asymptotic chroma.
        if (reuleaux.y <= norm_mults.y)
            cart.z = 1.0f / tan(reuleaux.y);
        else
            cart.z = 1.0f / (3.0f * (reuleaux.y - norm_mults.y) + sqrt(2.0f));

        float d_1 = sqrt(2.0f) * cart.z + (2.0f * cart.x);
        float d_2 = sqrt(2.0f) * cart.z + sqrt(3.0f) * cart.y - cart.x;
        float d_3 = sqrt(2.0f) * cart.z - sqrt(3.0f) * cart.y - cart.x;
        float m = max(d_1, max(d_2, d_3)) / 3.0f;

        float3 ocs = float3(
            fabs(m) < 1e-6f ? 0.0f : reuleaux.z * cart.x / m,
            fabs(m) < 1e-6f ? 0.0f : reuleaux.z * cart.y / m,
            reuleaux.z
        );

        float3 rgb;
        bool case_1 = (ocs.y <= 0.0f || ocs.x > 0.0f) && (ocs.x <= 0.0f || ocs.y <= -sqrt(3.0f) * ocs.x);
        bool case_2 = (ocs.y > 0.0f || ocs.x > 0.0f) && (ocs.x <= 0.0 || ocs.y > sqrt(3.0f) * ocs.x);

        if (case_1) {
            rgb.x = ocs.y / sqrt(3.0f) + ocs.x + ocs.z;
            rgb.y = 2.0f / sqrt(3.0f) * ocs.y + ocs.z;
            rgb.z = ocs.z;
        } else if (case_2) {
            rgb.x = -ocs.y / sqrt(3.0f) + ocs.x + ocs.z;
            rgb.y = ocs.z;
            rgb.z = -(2.0f / sqrt(3.0f)) * ocs.y + ocs.z;
        } else {
            rgb.x = ocs.z;
            rgb.y = ocs.y / sqrt(3.0f) - ocs.x + ocs.z;
            rgb.z = -ocs.y / sqrt(3.0f) - ocs.x + ocs.z;
        }

        return rgb;
    }

    void process() {
        SampleType(src) input = src();

        float3 triplet = float3(input.x, input.y, input.z);

        if (invert)
            triplet = reuleaux_to_rgb(triplet);
        else
            triplet = rgb_to_reuleaux(triplet);

        dst() = float4(triplet.x, triplet.y, triplet.z, input.w);
    }
};
